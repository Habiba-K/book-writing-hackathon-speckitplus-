# Function Contracts: RAG Agent Implementation

**Feature**: 001-rag-agent
**Date**: 2025-12-19

## Overview

Function contracts for the RAG agent implementation in agent.py that integrates with existing retrieval functionality from retrieving.py and supports single clickable source display and out-of-scope query handling.

---
## 1. create_rag_agent

```python
def create_rag_agent() -> GroqClient:
    """
    Create and configure the RAG agent using Groq API.

    Returns:
        Configured Groq client instance that can process queries
        using the retrieval functionality from retrieving.py

    Dependencies:
        Requires GROQ_API_KEY environment variable
        Uses retrieve function from retrieving module
    """
```

---
## 2. process_query_with_agent

```python
def process_query_with_agent(query: str) -> dict:
    """
    Process a user query through the RAG agent.

    Args:
        query: Natural language question or request from user

    Returns:
        Dictionary with structure:
        {
            "answer": str - contextual answer generated by agent,
            "primary_source": dict - the single primary source for clickable display,
            "sources": list[dict] - list of all source documents used (for JSON response),
            "matched_chunks": list[dict] - content chunks retrieved from Qdrant,
            "query_time": float - time taken to process request in seconds,
            "success": bool - whether operation completed successfully,
            "is_out_of_scope": bool - whether the query was out of the book's scope
        }

    Raises:
        ValueError: If query is empty or invalid
        Exception: If agent processing fails

    Example (in scope):
        response = process_query_with_agent("What is ROS 2?")
        # Returns: {
        #     "answer": "ROS 2 is a flexible framework...",
        #     "primary_source": {"url": "...", "name": "..."},
        #     "sources": [{"url": "...", "title": "...", "chunk_index": 0}],
        #     "matched_chunks": [{"text": "...", "similarity_score": 0.85, "source": {...}}],
        #     "query_time": 1.25,
        #     "success": True,
        #     "is_out_of_scope": False
        # }

    Example (out of scope):
        response = process_query_with_agent("What is quantum physics?")
        # Returns: {
        #     "answer": "sorry this content is not related to this book",
        #     "primary_source": None,
        #     "sources": [],
        #     "matched_chunks": [],
        #     "query_time": 0.1,
        #     "success": True,
        #     "is_out_of_scope": True
        # }
    """
```

---
## 3. format_agent_response

```python
def format_agent_response(retrieval_results: dict, query_time: float, query: str) -> dict:
    """
    Format retrieval results into the required agent response structure with single primary source.

    Args:
        retrieval_results: Results from the retrieve function in retrieving.py
        query_time: Time taken to process the query in seconds
        query: The original query to check if it's in scope

    Returns:
        Formatted response dictionary matching the required structure with single primary source

    Example:
        formatted = format_agent_response(retrieval_results, 1.25, "What is ROS 2?")
        # Returns properly structured response with answer, primary_source, sources, chunks
    """
```

---
## 4. select_primary_source

```python
def select_primary_source(sources: list) -> dict:
    """
    Select the most relevant source to be displayed as the single clickable source.

    Args:
        sources: List of all retrieved sources

    Returns:
        The most relevant source to display as primary source

    Selection criteria:
        - Highest similarity score
        - Most relevant to the query
        - Prefer sources with higher confidence
    """
```

---
## 5. check_query_scope

```python
def check_query_scope(query: str) -> bool:
    """
    Check if the query is within the book's scope.

    Args:
        query: The user's query to check

    Returns:
        Boolean indicating if the query is within the book's scope

    Scope includes:
        - Physical AI & Humanoid Robotics topics
        - ROS 2, Isaac, Qdrant, and related technologies
        - Book content as defined in the sitemap
    """
```

---
## 6. validate_agent_input

```python
def validate_agent_input(query: str) -> bool:
    """
    Validate agent input parameters.

    Args:
        query: User query to validate

    Returns:
        Boolean indicating if input is valid

    Validation checks:
        - Query is not empty
        - Query length is within acceptable limits
        - Query contains valid characters
    """
```

---
## 7. handle_agent_error

```python
def handle_agent_error(error: Exception, query: str) -> dict:
    """
    Handle errors that occur during agent processing.

    Args:
        error: Exception that occurred during processing
        query: Original query that caused the error

    Returns:
        Error response in standard format with appropriate error message
    """
```

## Constants

```python
AGENT_NAME = "RAG-Agent"
AGENT_INSTRUCTIONS = "You are a helpful assistant that answers questions using retrieved information from the Physical AI & Humanoid Robotics book content. Provide concise answers and cite sources. If the question is not related to the book content, respond with 'Unfortunately, the provided context does not contain sufficient information about that topic.'"
AGENT_MODEL = "llama-3.1-8b-instant"  # Groq-supported model
MAX_QUERY_LENGTH = 2000  # Maximum length of user query in characters
DEFAULT_TIMEOUT = 30  # Default timeout for agent operations in seconds
OUT_OF_SCOPE_RESPONSE = "Unfortunately, the provided context does not contain sufficient information about that topic."
```